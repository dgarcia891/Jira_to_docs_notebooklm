import{f as y,n as E}from"./docUtils-CDeOq3Hw.js";const I=s=>{try{const o=s.replace("#","?");return new URL(o).searchParams.get("access_token")}catch{return null}};class N{scopes=["https://www.googleapis.com/auth/documents","https://www.googleapis.com/auth/drive","https://www.googleapis.com/auth/userinfo.email"];clientId="342225464153-i3qd0aru6fsna13sg2i0qmvtofnktgmb.apps.googleusercontent.com";async fetchToken(o){console.log(`GoogleAuth: fetchToken called (interactive: ${o})`);const e=await new Promise(t=>{if(typeof chrome>"u"||!chrome.identity||!chrome.identity.getAuthToken){t(null);return}chrome.identity.getAuthToken({interactive:o},n=>{chrome.runtime?.lastError||!n?(console.warn("GoogleAuth: Native getAuthToken failed/returned nothing:",chrome.runtime?.lastError?.message||"No token"),t(null)):t(n)})});return e?(await chrome.storage.local.set({auth_token:e,token_expiry:Date.now()+3e3*1e3}),e):o?(console.log("GoogleAuth: Attempting Fallback launchWebAuthFlow..."),new Promise(t=>{const n=chrome.identity.getRedirectURL(),r=`https://accounts.google.com/o/oauth2/auth?client_id=${this.clientId}&response_type=token&redirect_uri=${encodeURIComponent(n)}&scope=${encodeURIComponent(this.scopes.join(" "))}&prompt=consent`;chrome.identity.launchWebAuthFlow({url:r,interactive:!0},i=>{if(chrome.runtime?.lastError||!i)console.error("GoogleAuth: Fallback Auth Failed:",chrome.runtime?.lastError?.message),t(null);else{const c=I(i);c&&chrome.storage.local.set({auth_token:c,token_expiry:Date.now()+3e3*1e3}),t(c)}})})):null}async login(){const o=await this.fetchToken(!0);if(!o){const e=chrome.runtime?.lastError?.message;throw new Error(`Authentication failed: ${e||"No token returned"}`)}return o}async getToken(){const o=await chrome.storage.local.get(["auth_token","token_expiry"]),e=o.auth_token,t=o.token_expiry;if(e&&t&&t>Date.now()+300*1e3)return console.log("GoogleAuth: Using valid cached token from storage."),e;console.log("GoogleAuth: Storage token missing/expired. Attempting silent fetch...");const n=await this.fetchToken(!1);return!n&&e&&(console.warn("GoogleAuth: Silent refresh failed. Clearing stale token."),await this.clearCachedToken(e)),n}async clearCachedToken(o){console.log("GoogleAuth: Clearing cached token..."),await chrome.storage.local.remove(["auth_token","token_expiry","userInfo"]),o&&typeof chrome<"u"&&chrome.identity?.removeCachedAuthToken&&await new Promise(e=>{chrome.identity.removeCachedAuthToken({token:o},()=>e())})}async getUserInfo(o){const e=await fetch("https://www.googleapis.com/oauth2/v2/userinfo",{headers:{Authorization:`Bearer ${o}`}});if(!e.ok)throw new Error("Failed to fetch user info");return await e.json()}async logout(){await chrome.storage.local.remove(["auth_token","token_expiry","userInfo"]);try{const o=await this.getToken();o&&await new Promise(e=>{chrome.identity.removeCachedAuthToken({token:o},()=>e())})}catch{}console.log("GoogleAuth: Logged out and identity cache cleared.")}}class v{baseUrl="https://docs.googleapis.com/v1/documents";driveUrl="https://www.googleapis.com/drive/v3/files";async authFetch(o,e,t){let n=await fetch(o,e);return n.status===401&&(console.warn(`DocsSync: 401 Unauthorized for ${o}. Clearing token and retrying...`),await chrome.storage.local.remove(["auth_token","token_expiry"])),n}async createDoc(o,e,t){const n=await this.authFetch(this.baseUrl,{method:"POST",headers:{Authorization:`Bearer ${e}`,"Content-Type":"application/json"},body:JSON.stringify({title:o})},e);if(!n.ok){const c=await n.text();throw new Error(`Failed to create doc (${n.status}): ${c}`)}const i=(await n.json()).documentId;return t&&await this.moveToFolder(i,t,e),i}async moveToFolder(o,e,t){const i=((await(await this.authFetch(`${this.driveUrl}/${o}?fields=parents`,{headers:{Authorization:`Bearer ${t}`}},t)).json()).parents||[]).join(",");await this.authFetch(`${this.driveUrl}/${o}?addParents=${e}&removeParents=${i}`,{method:"PATCH",headers:{Authorization:`Bearer ${t}`}},t)}async listDocs(o){const t=await this.authFetch(`${this.driveUrl}?q=${encodeURIComponent("mimeType='application/vnd.google-apps.document' and trashed=false")}&fields=files(id,name)`,{headers:{Authorization:`Bearer ${o}`}},o);if(!t.ok){const r=await t.text();throw new Error(`Failed to list docs (${t.status}): ${r}`)}return(await t.json()).files||[]}async searchDocs(o,e){const t=`mimeType='application/vnd.google-apps.document' and name contains '${e.replace(/'/g,"\\'")}' and trashed=false`,n=await this.authFetch(`${this.driveUrl}?q=${encodeURIComponent(t)}&fields=files(id,name)&orderBy=modifiedTime desc`,{headers:{Authorization:`Bearer ${o}`}},o);if(!n.ok){const i=await n.text();throw new Error(`Failed to search docs (${n.status}): ${i}`)}return(await n.json()).files||[]}async listFolders(o,e){let t="mimeType='application/vnd.google-apps.folder' and trashed=false";e&&(t+=` and '${e}' in parents`);const n=await this.authFetch(`${this.driveUrl}?q=${encodeURIComponent(t)}&fields=files(id,name)&orderBy=name`,{headers:{Authorization:`Bearer ${o}`}},o);if(!n.ok){const i=await n.text();throw new Error(`Failed to list folders (${n.status}): ${i}`)}return(await n.json()).files||[]}async syncItem(o,e,t){return this.syncItems(o,[e],t)}async syncItems(o,e,t){const n=await this.getDoc(o,t),r=n.body.content[n.body.content.length-1].endIndex;console.log(`DocsSyncService: Wiping and syncing ${e.length} items to ${o}`);const i=[];r>2&&i.push({deleteContentRange:{range:{startIndex:1,endIndex:r-1}}});for(const a of e){const g=a.comments&&a.comments.length>0?a.comments.map(d=>`[${d.timestamp||"Unknown"}] ${d.author}: ${d.body.replace(/\*\*/g,"")}`).join(`
`):"_No recent comments_",w=[`Status: ${a.status}`,`Story Points: ${a.storyPoints||"N/A"}`,`Reporter: ${a.reporter||"N/A"}`,`Assignee: ${a.assignee||"Unassigned"}`,`Sprint History: ${a.sprints&&a.sprints.length>0?a.sprints.join(", "):"No Sprints"}`,`T-Shirt Size: ${a.tShirtSize||"N/A"}`,`Work Type: ${a.workType||"N/A"}`,`Business Team: ${a.businessTeam||"N/A"}`,`Business Objective: ${a.businessObjective||"N/A"}`,`Impact: ${a.impact||"N/A"}`,`Labels: ${a.labels&&a.labels.length>0?a.labels.join(", "):"None"}`,`Synced: ${y(new Date)}`,`Created: ${y(a.createdDate)} | Updated: ${y(a.updatedDate)}`].join(`
`);let f="";a.linkedIssues&&a.linkedIssues.length>0&&(f=`
Linked Tickets:
`+a.linkedIssues.map(d=>`* ${d.key}: ${d.title}
  - T-Shirt: ${d.tShirtSize||"N/A"}
  - Context: ${d.rationale||"N/A"}`).join(`
`)),`${a.key}${a.title}`,`${w}${a.url}${a.description}${f}${g}`}let c="";const m=[];for(const a of e){const g=a.comments&&a.comments.length>0?a.comments.map(l=>`[${l.timestamp||"Unknown"}] ${l.author}: ${l.body.replace(/\*\*/g,"")}`).join(`
`):"_No recent comments_",w=[`Status: ${a.status}`,`Story Points: ${a.storyPoints||"N/A"}`,`Reporter: ${a.reporter||"N/A"}`,`Assignee: ${a.assignee||"Unassigned"}`,`Sprint History: ${a.sprints&&a.sprints.length>0?a.sprints.join(", "):"No Sprints"}`,`T-Shirt Size: ${a.tShirtSize||"N/A"}`,`Work Type: ${a.workType||"N/A"}`,`Business Team: ${a.businessTeam||"N/A"}`,`Business Objective: ${a.businessObjective||"N/A"}`,`Impact: ${a.impact||"N/A"}`,`Labels: ${a.labels&&a.labels.length>0?a.labels.join(", "):"None"}`,`Synced: ${y(new Date)}`,`Created: ${y(a.createdDate)} | Updated: ${y(a.updatedDate)}`].join(`
`);let f="";a.linkedIssues&&a.linkedIssues.length>0&&(f=`
Linked Tickets:
`+a.linkedIssues.map(l=>{const U=l.comments&&l.comments.length>0?`
    Comments:
    `+l.comments.map(S=>`[${S.timestamp}] ${S.author}: ${S.body}`).join(`
    `):"";return`* ${l.key}: ${l.title}
  - Status: ${l.status||"N/A"} | Priority: ${l.priority||"N/A"}
  - Description: ${l.description||"No description"}
  - Link: ${l.url}${U}`}).join(`

`));const d=`${a.key}: ${a.title}
`,D=c.length+1;c+=d;const C=c.length+1;m.push({start:D,end:C,type:"HEADING_1"});const _=`${w}
Link: ${a.url}

Description
${a.description}
${f}

--------------------------------------------------
Latest Comments
${g}

---

`,A=c.length+1;c+=_;const b=c.length+1;m.push({start:A,end:b,type:"NORMAL_TEXT"})}i.push({insertText:{location:{index:1},text:c}});for(const a of m)i.push({updateParagraphStyle:{range:{startIndex:a.start,endIndex:a.end-1},paragraphStyle:{namedStyleType:a.type},fields:"namedStyleType"}});await this.batchUpdate(o,t,i)}async getDoc(o,e){const t=await this.authFetch(`${this.baseUrl}/${o}`,{headers:{Authorization:`Bearer ${e}`}},e);if(!t.ok){const n=await t.text();throw console.error(`DocsSync API Error [Get]: ${t.status}`,n),new Error(`Failed to fetch doc (${t.status}): ${n}`)}return await t.json()}async batchUpdate(o,e,t){const n=await this.authFetch(`${this.baseUrl}/${o}:batchUpdate`,{method:"POST",headers:{Authorization:`Bearer ${e}`,"Content-Type":"application/json"},body:JSON.stringify({requests:t})},e);if(!n.ok){const r=await n.text();throw console.error(`DocsSync API Error [BatchUpdate]: ${n.status}`,r),new Error(`Failed to update doc (${n.status}): ${r}`)}}}console.log("Jira to NotebookLM: Background service worker loaded");const $=async(s,o)=>{if(s.includes(".chromiumapp.org/")&&s.includes("access_token=")){console.log("Background: Intercepted Token URL:",s);try{const e=s.replace("#","?"),t=new URL(e),n=t.searchParams.get("access_token"),r=t.searchParams.get("expires_in");if(n){const i=Date.now()+parseInt(r||"3599")*1e3;await chrome.storage.local.set({auth_token:n,token_expiry:i}),console.log("Background: Auth successful. Notifying popup and closing tab."),chrome.runtime.sendMessage({type:"AUTH_SUCCESS"}).catch(()=>{}),setTimeout(()=>{chrome.tabs.remove(o).catch(()=>{})},100)}}catch(e){console.error("Background: Token extraction error:",e)}}};chrome.tabs.onUpdated.addListener((s,o,e)=>{o.url&&$(o.url,s)});chrome.tabs.onCreated.addListener(s=>{s.id&&s.url&&$(s.url,s.id)});chrome.webNavigation.onBeforeNavigate.addListener(s=>{s.frameId===0&&$(s.url,s.tabId)});chrome.webNavigation.onCommitted.addListener(s=>{s.frameId===0&&$(s.url,s.tabId)});const u=new N,p=new v;chrome.runtime.onMessage.addListener((s,o,e)=>(T(s).then(e).catch(t=>{if(!t.message?.includes("Extension updated")){const r={message:t.message||"Unknown error",name:t.name,stack:t.stack,original:t};console.error("Background Error Detailed:",JSON.stringify(r,null,2))}e({error:t.message||JSON.stringify(t)})}),!0));async function T(s,o=0){try{switch(s.type){case"LOGIN":return console.log("Background: Triggering LOGIN flow..."),await u.login();case"CHECK_AUTH":return await u.getToken();case"LIST_DOCS":{const e=await u.getToken();if(!e)throw new Error("Not authenticated");return await p.listDocs(e)}case"LIST_DRIVE_FOLDERS":{const e=await u.getToken();if(!e)throw new Error("Not authenticated");return await p.listFolders(e,s.payload?.parentId)}case"SEARCH_DOCS":{const e=await u.getToken();if(!e)throw new Error("Not authenticated");return await p.searchDocs(e,s.payload.query)}case"CREATE_DOC":{const e=await u.getToken();if(!e)throw new Error("Not authenticated");return await p.createDoc(s.payload.title,e,s.payload.folderId)}case"GET_CURRENT_ISSUE_KEY":{const[e]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!e?.id)throw new Error("No active tab found.");try{const t=await chrome.tabs.sendMessage(e.id,{type:"GET_ISSUE_KEY"});if(t.error)throw new Error(t.error);return t}catch(t){throw console.warn("Background: GET_CURRENT_ISSUE_KEY failed",t),t.message?.includes("Could not establish connection")||t.message?.includes("context invalidated")?new Error("Extension updated. Please refresh your Jira page to continue."):new Error("Please open the extension on a Jira issue page.")}}case"GET_SELECTED_DOC":{const e=await chrome.storage.local.get("selectedDoc");return E(e.selectedDoc)}case"SET_SELECTED_DOC":return await chrome.storage.local.set({selectedDoc:s.payload}),!0;case"REFRESH_TAB":{const[e]=await chrome.tabs.query({active:!0,currentWindow:!0});return e?.id&&await chrome.tabs.reload(e.id),{success:!0}}case"SYNC_CURRENT_PAGE":return await L();case"SYNC_EPIC":return await B(s.payload.epicKey);case"GET_ISSUE_DOC_LINK":{const{issueKey:e}=s.payload;return(await k())[e]||null}case"CLEAR_ISSUE_DOC_LINK":{const{issueKey:e}=s.payload,t=await k();return delete t[e],await chrome.storage.local.set({issueDocLinks:t}),!0}case"GET_LAST_SYNC":{const{issueKey:e}=s.payload;return((await chrome.storage.local.get("issueSyncTimes")).issueSyncTimes||{})[e]||null}case"LOGOUT":return await u.logout()}}catch(e){if(e.message?.includes("401")&&o===0)return console.warn("Background: 401 detected in handleMessage. Clearing cache and retrying..."),await u.clearCachedToken(),await T(s,1);throw e}}async function k(){const o=(await chrome.storage.local.get("issueDocLinks")).issueDocLinks||{},e={};for(const t in o){const n=E(o[t]);n&&(e[t]=n)}return e}async function h(s){await chrome.storage.local.set({activeSyncState:s}),chrome.runtime.sendMessage({type:"SYNC_STATE_UPDATE",payload:s}).catch(()=>{})}async function L(){try{const s=await u.getToken();if(!s)throw new Error("Not authenticated");const[o]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!o?.id)throw new Error("No active tab");await h({isSyncing:!0,progress:10,status:"Initializing...",key:"pending"});const e=await chrome.tabs.sendMessage(o.id,{type:"EXTRACT_ISSUE"});if(e.type==="EXTRACT_ERROR")throw new Error(e.error);if(e.type!=="EXTRACT_SUCCESS")throw new Error("Unexpected response type from content script");const t=e.payload.key;await h({isSyncing:!0,progress:30,status:`Fetched ${t}`,key:t});const n=await k();let r;if(n[t])r=n[t];else{const{selectedDoc:a}=await chrome.storage.local.get("selectedDoc");if(!a)throw new Error("No target Document selected. Select one to link this issue.");r=a,n[t]=r,await chrome.storage.local.set({issueDocLinks:n})}await h({isSyncing:!0,progress:60,status:`Syncing ${t} to Google Docs...`,key:t}),await p.syncItem(r.id,e.payload,s),console.log(`Background: Sync successful for ${t} to ${r.name}`);const c=(await chrome.storage.local.get("issueSyncTimes")).issueSyncTimes||{},m={status:"success",time:Date.now(),message:`Synced to ${r.name}`,type:"single"};return c[t]=m,await chrome.storage.local.set({issueSyncTimes:c}),await h({isSyncing:!1,progress:100,status:"Complete!",key:t,result:m}),{success:!0,key:t,id:r.id}}catch(s){console.error("Background Sync Error:",s);let o=s.message;if(s.message?.includes("404")){o="The linked Google Doc no longer exists or is inaccessible. The local link has been cleared.";try{const e=await k(),[t]=await chrome.tabs.query({active:!0,currentWindow:!0});if(t?.id){const r=await chrome.tabs.sendMessage(t.id,{type:"EXTRACT_ISSUE"});if(r.type==="EXTRACT_SUCCESS"){const i=r.payload.key;e[i]&&(delete e[i],await chrome.storage.local.set({issueDocLinks:e}))}}const{selectedDoc:n}=await chrome.storage.local.get("selectedDoc");n&&await chrome.storage.local.remove("selectedDoc")}catch(e){console.error("Failed to cleanup dead links after 404:",e)}}throw await h({isSyncing:!1,progress:0,status:`Error: ${o}`,result:{status:"error",message:o,time:Date.now()}}),s}}async function B(s){try{const o=await u.getToken();if(!o)throw new Error("Google Docs not authenticated. Please disconnect and reconnect.");await h({isSyncing:!0,progress:5,status:"Initializing Bulk Sync...",key:s});const e=await k();let t=e[s];if(!t){const w=(await chrome.storage.local.get("selectedDoc")).selectedDoc;if(!w)throw new Error("No target Document selected. Link the Epic first.");t=w,e[s]=t,await chrome.storage.local.set({issueDocLinks:e})}const[n]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!n?.id)throw new Error("No active tab");const r=await chrome.tabs.sendMessage(n.id,{type:"FETCH_EPIC_BULK",payload:{epicKey:s}});if(r.type==="EXTRACT_ERROR")throw new Error(r.error);if(r.type!=="EPIC_BULK_SUCCESS")throw new Error("Expected EPIC_BULK_SUCCESS");const i=r.payload.items;console.log(`Background: Found ${i.length} issues in Epic ${s}`),await h({isSyncing:!0,progress:60,status:`Gathered ${i.length} items. Writing to Google Doc...`,key:s}),await p.syncItems(t.id,i,o);for(const g of i)e[g.key]||(e[g.key]=t);await chrome.storage.local.set({issueDocLinks:e});const m=(await chrome.storage.local.get("issueSyncTimes")).issueSyncTimes||{},a={status:"success",time:Date.now(),message:`Bulk synced ${i.length} issues to ${t.name}`,type:"bulk"};return m[s]=a,await chrome.storage.local.set({issueSyncTimes:m}),await h({isSyncing:!1,progress:100,status:"Bulk Sync Complete!",key:s,result:a}),{success:!0,count:i.length,key:s,id:t.id}}catch(o){console.error("Background Bulk Sync Error:",o);let e=o.message;if(o.message?.includes("404")){e="The linked Google Doc no longer exists. The link has been cleared.";try{const t=await k();t[s]&&(delete t[s],await chrome.storage.local.set({issueDocLinks:t}));const{selectedDoc:n}=await chrome.storage.local.get("selectedDoc");n&&await chrome.storage.local.remove("selectedDoc")}catch(t){console.error("Failed cleanup:",t)}}throw await h({isSyncing:!1,progress:0,status:`Error: ${e}`,key:s,result:{status:"error",message:e,time:Date.now()}}),o}}chrome.runtime.onMessage.addListener(s=>{if(s.type==="EPIC_BULK_PROGRESS"){const{current:o,total:e,key:t}=s.payload,n=5+Math.floor(o/e*55);h({isSyncing:!0,progress:n,status:`Processing ${t} (${o}/${e})...`,key:t})}});
