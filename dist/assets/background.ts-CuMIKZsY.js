import{f as k,a as I,n as T}from"./docUtils-BQsI6kcp.js";const v=s=>{try{const o=s.replace("#","?");return new URL(o).searchParams.get("access_token")}catch{return null}};class R{scopes=["https://www.googleapis.com/auth/documents","https://www.googleapis.com/auth/drive","https://www.googleapis.com/auth/userinfo.email"];clientId="342225464153-i3qd0aru6fsna13sg2i0qmvtofnktgmb.apps.googleusercontent.com";async fetchToken(o){console.log(`GoogleAuth: fetchToken called (interactive: ${o})`);const e=await new Promise(t=>{if(typeof chrome>"u"||!chrome.identity||!chrome.identity.getAuthToken){t(null);return}chrome.identity.getAuthToken({interactive:o},a=>{chrome.runtime?.lastError||!a?(console.warn("GoogleAuth: Native getAuthToken failed/returned nothing:",chrome.runtime?.lastError?.message||"No token"),t(null)):t(a)})});return e?(await chrome.storage.local.set({auth_token:e,token_expiry:Date.now()+3e3*1e3}),e):o?(console.log("GoogleAuth: Attempting Fallback launchWebAuthFlow..."),new Promise(t=>{const a=chrome.identity.getRedirectURL(),n=`https://accounts.google.com/o/oauth2/auth?client_id=${this.clientId}&response_type=token&redirect_uri=${encodeURIComponent(a)}&scope=${encodeURIComponent(this.scopes.join(" "))}&prompt=consent`;chrome.identity.launchWebAuthFlow({url:n,interactive:!0},c=>{if(chrome.runtime?.lastError||!c)console.error("GoogleAuth: Fallback Auth Failed:",chrome.runtime?.lastError?.message),t(null);else{const i=v(c);i&&chrome.storage.local.set({auth_token:i,token_expiry:Date.now()+3e3*1e3}),t(i)}})})):null}async login(){const o=await this.fetchToken(!0);if(!o){const e=chrome.runtime?.lastError?.message;throw new Error(`Authentication failed: ${e||"No token returned"}`)}return o}async getToken(){const o=await chrome.storage.local.get(["auth_token","token_expiry"]),e=o.auth_token,t=o.token_expiry;if(e&&t&&t>Date.now()+300*1e3)return console.log("GoogleAuth: Using valid cached token from storage."),e;console.log("GoogleAuth: Storage token missing/expired. Attempting silent fetch...");const a=await this.fetchToken(!1);return!a&&e&&(console.warn("GoogleAuth: Silent refresh failed. Clearing stale token."),await this.clearCachedToken(e)),a}async clearCachedToken(o){console.log("GoogleAuth: Clearing cached token..."),await chrome.storage.local.remove(["auth_token","token_expiry","userInfo"]),o&&typeof chrome<"u"&&chrome.identity?.removeCachedAuthToken&&await new Promise(e=>{chrome.identity.removeCachedAuthToken({token:o},()=>e())})}async getUserInfo(o){const e=await fetch("https://www.googleapis.com/oauth2/v2/userinfo",{headers:{Authorization:`Bearer ${o}`}});if(!e.ok)throw new Error("Failed to fetch user info");return await e.json()}async logout(){await chrome.storage.local.remove(["auth_token","token_expiry","userInfo"]);try{const o=await this.getToken();o&&await new Promise(e=>{chrome.identity.removeCachedAuthToken({token:o},()=>e())})}catch{}console.log("GoogleAuth: Logged out and identity cache cleared.")}}class N{baseUrl="https://docs.googleapis.com/v1/documents";driveUrl="https://www.googleapis.com/drive/v3/files";async authFetch(o,e,t){let a=await fetch(o,e);return a.status===401&&(console.warn(`DocsSync: 401 Unauthorized for ${o}. Clearing token and retrying...`),await chrome.storage.local.remove(["auth_token","token_expiry"])),a}async createDoc(o,e,t){const a=await this.authFetch(this.baseUrl,{method:"POST",headers:{Authorization:`Bearer ${e}`,"Content-Type":"application/json"},body:JSON.stringify({title:o})},e);if(!a.ok){const i=await a.text();throw new Error(`Failed to create doc (${a.status}): ${i}`)}const c=(await a.json()).documentId;return t&&await this.moveToFolder(c,t,e),c}async moveToFolder(o,e,t){const c=((await(await this.authFetch(`${this.driveUrl}/${o}?fields=parents`,{headers:{Authorization:`Bearer ${t}`}},t)).json()).parents||[]).join(",");await this.authFetch(`${this.driveUrl}/${o}?addParents=${e}&removeParents=${c}`,{method:"PATCH",headers:{Authorization:`Bearer ${t}`}},t)}async listDocs(o){const t=await this.authFetch(`${this.driveUrl}?q=${encodeURIComponent("mimeType='application/vnd.google-apps.document' and trashed=false")}&fields=files(id,name)`,{headers:{Authorization:`Bearer ${o}`}},o);if(!t.ok){const n=await t.text();throw new Error(`Failed to list docs (${t.status}): ${n}`)}return(await t.json()).files||[]}async searchDocs(o,e){const t=`(mimeType='application/vnd.google-apps.document' or mimeType='application/vnd.google-apps.folder') and name contains '${e.replace(/'/g,"\\'")}' and trashed=false`,a=await this.authFetch(`${this.driveUrl}?q=${encodeURIComponent(t)}&fields=files(id,name,mimeType)&orderBy=modifiedTime desc`,{headers:{Authorization:`Bearer ${o}`}},o);if(!a.ok){const c=await a.text();throw new Error(`Failed to search docs (${a.status}): ${c}`)}return(await a.json()).files||[]}async listFolders(o,e){let t="(mimeType='application/vnd.google-apps.folder' or mimeType='application/vnd.google-apps.document') and trashed=false";e&&(t+=` and '${e}' in parents`);const a=await this.authFetch(`${this.driveUrl}?q=${encodeURIComponent(t)}&fields=files(id,name,mimeType)&orderBy=folder,name`,{headers:{Authorization:`Bearer ${o}`}},o);if(!a.ok){const c=await a.text();throw new Error(`Failed to list folders (${a.status}): ${c}`)}return(await a.json()).files||[]}async syncItem(o,e,t){return this.syncItems(o,[e],t)}async syncItems(o,e,t){const a=await this.getDoc(o,t),n=a.body.content[a.body.content.length-1].endIndex;console.log(`DocsSyncService: Wiping and syncing ${e.length} items to ${o}`);const c=[];n>2&&c.push({deleteContentRange:{range:{startIndex:1,endIndex:n-1}}});let i="";const h=[];for(const r of e){const w=r.comments&&r.comments.length>0?r.comments.map(l=>`[${l.timestamp||"Unknown"}] ${l.author}: ${l.body.replace(/\*\*/g,"")}`).join(`
`):"_No recent comments_",y=[`Status: ${r.status}`,`Story Points: ${r.storyPoints||"N/A"}`,`Reporter: ${r.reporter||"N/A"}`,`Assignee: ${r.assignee||"Unassigned"}`,`Sprint History: ${r.sprints&&r.sprints.length>0?r.sprints.join(", "):"No Sprints"}`,`T-Shirt Size: ${r.tShirtSize||"N/A"}`,`Work Type: ${r.workType||"N/A"}`,`Business Team: ${r.businessTeam||"N/A"}`,`Business Objective: ${r.businessObjective||"N/A"}`,`Impact: ${r.impact||"N/A"}`,`Labels: ${r.labels&&r.labels.length>0?r.labels.join(", "):"None"}`,`Synced: ${k(new Date)}`,`Created: ${k(r.createdDate)} | Updated: ${k(r.updatedDate)}`].join(`
`);let E="";r.linkedIssues&&r.linkedIssues.length>0&&(E=`
Linked Tickets:
`+r.linkedIssues.map(l=>{const U=l.comments&&l.comments.length>0?`
    Comments:
    `+l.comments.map(f=>`[${f.timestamp}] ${f.author}: ${f.body}`).join(`
    `):"";return`* ${l.key}: ${l.title}
  - Status: ${l.status||"N/A"} | Priority: ${l.priority||"N/A"}
  - Description: ${l.description||"No description"}
  - Link: ${l.url}${U}`}).join(`

`));const $=`${r.key}: ${r.title}
`,C=i.length+1;i+=$;const _=i.length+1;h.push({start:C,end:_,type:"HEADING_1"});const D=`${y}
Link: ${r.url}

Description
${r.description}
${E}

--------------------------------------------------
Latest Comments
${w}

---

`,A=i.length+1;i+=D;const b=i.length+1;h.push({start:A,end:b,type:"NORMAL_TEXT"})}c.push({insertText:{location:{index:1},text:i}});for(const r of h)c.push({updateParagraphStyle:{range:{startIndex:r.start,endIndex:r.end-1},paragraphStyle:{namedStyleType:r.type},fields:"namedStyleType"}});await this.batchUpdate(o,t,c)}async getDoc(o,e){const t=await this.authFetch(`${this.baseUrl}/${o}`,{headers:{Authorization:`Bearer ${e}`}},e);if(!t.ok){const a=await t.text();throw console.error(`DocsSync API Error [Get]: ${t.status}`,a),new Error(`Failed to fetch doc (${t.status}): ${a}`)}return await t.json()}async batchUpdate(o,e,t){const a=await this.authFetch(`${this.baseUrl}/${o}:batchUpdate`,{method:"POST",headers:{Authorization:`Bearer ${e}`,"Content-Type":"application/json"},body:JSON.stringify({requests:t})},e);if(!a.ok){const n=await a.text();throw console.error(`DocsSync API Error [BatchUpdate]: ${a.status}`,n),new Error(`Failed to update doc (${a.status}): ${n}`)}}}console.log("Jira to NotebookLM: Background service worker loaded");const p=async(s,o)=>{if(s.includes(".chromiumapp.org/")&&s.includes("access_token=")){console.log("Background: Intercepted Token URL:",s);try{const e=s.replace("#","?"),t=new URL(e),a=t.searchParams.get("access_token"),n=t.searchParams.get("expires_in");if(a){const c=Date.now()+parseInt(n||"3599")*1e3;await chrome.storage.local.set({auth_token:a,token_expiry:c}),console.log("Background: Auth successful. Notifying popup and closing tab."),chrome.runtime.sendMessage({type:"AUTH_SUCCESS"}).catch(()=>{}),setTimeout(()=>{chrome.tabs.remove(o).catch(()=>{})},100)}}catch(e){console.error("Background: Token extraction error:",e)}}};chrome.tabs.onUpdated.addListener((s,o,e)=>{o.url&&p(o.url,s)});chrome.tabs.onCreated.addListener(s=>{s.id&&s.url&&p(s.url,s.id)});chrome.webNavigation.onBeforeNavigate.addListener(s=>{s.frameId===0&&p(s.url,s.tabId)});chrome.webNavigation.onCommitted.addListener(s=>{s.frameId===0&&p(s.url,s.tabId)});const d=new R,g=new N;chrome.runtime.onMessage.addListener((s,o,e)=>(S(s).then(e).catch(t=>{if(!t.message?.includes("Extension updated")){const n={message:t.message||"Unknown error",name:t.name,stack:t.stack,original:t};console.error("Background Error Detailed:",JSON.stringify(n,null,2))}e({error:t.message||JSON.stringify(t)})}),!0));async function S(s,o=0){try{switch(s.type){case"LOGIN":return console.log("Background: Triggering LOGIN flow..."),await d.login();case"CHECK_AUTH":return await d.getToken();case"LIST_DOCS":{const e=await d.getToken();if(!e)throw new Error("Not authenticated");return await g.listDocs(e)}case"LIST_DRIVE_FOLDERS":{const e=await d.getToken();if(!e)throw new Error("Not authenticated");return await g.listFolders(e,s.payload?.parentId)}case"SEARCH_DOCS":{const e=await d.getToken();if(!e)throw new Error("Not authenticated");return await g.searchDocs(e,s.payload.query)}case"CREATE_DOC":{const e=await d.getToken();if(!e)throw new Error("Not authenticated");return await g.createDoc(s.payload.title,e,s.payload.folderId)}case"GET_CURRENT_ISSUE_KEY":{const[e]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!e?.id)throw new Error("No active tab found.");try{const t=await chrome.tabs.sendMessage(e.id,{type:"GET_ISSUE_KEY"});if(t.error)throw new Error(t.error);return t}catch(t){throw console.warn("Background: GET_CURRENT_ISSUE_KEY failed",t),t.message?.includes("Could not establish connection")||t.message?.includes("context invalidated")?new Error("Extension updated. Please refresh your Jira page to continue."):new Error("Please open the extension on a Jira issue page.")}}case"GET_SELECTED_DOC":{const e=await chrome.storage.local.get("selectedDoc");return T(e.selectedDoc)}case"SET_SELECTED_DOC":return await chrome.storage.local.set({selectedDoc:s.payload}),!0;case"SYNC_CURRENT_PAGE":return await L();case"EXTRACT_FOR_COPY":{const[e]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!e?.id)throw new Error("No active tab found.");const t=await chrome.tabs.sendMessage(e.id,{type:"EXTRACT_ISSUE"});if(t.type==="EXTRACT_ERROR")throw new Error(t.error);if(t.type!=="EXTRACT_SUCCESS")throw new Error("Failed to extract issue.");return I(t.payload)}case"SYNC_EPIC":return await x(s.payload.epicKey);case"GET_ISSUE_DOC_LINK":{const{issueKey:e}=s.payload;return(await m())[e]||null}case"CLEAR_ISSUE_DOC_LINK":{const{issueKey:e}=s.payload,t=await m();return delete t[e],await chrome.storage.local.set({issueDocLinks:t}),!0}case"GET_LAST_SYNC":{const{issueKey:e}=s.payload;return((await chrome.storage.local.get("issueSyncTimes")).issueSyncTimes||{})[e]||null}case"LOGOUT":return await d.logout()}}catch(e){if(e.message?.includes("401")&&o===0)return console.warn("Background: 401 detected in handleMessage. Clearing cache and retrying..."),await d.clearCachedToken(),await S(s,1);throw e}}async function m(){const o=(await chrome.storage.local.get("issueDocLinks")).issueDocLinks||{},e={};for(const t in o){const a=T(o[t]);a&&(e[t]=a)}return e}async function u(s){await chrome.storage.local.set({activeSyncState:s}),chrome.runtime.sendMessage({type:"SYNC_STATE_UPDATE",payload:s}).catch(()=>{})}async function L(){try{await u({isSyncing:!0,progress:10,status:"Initializing...",key:"pending"});const s=await d.getToken();if(!s)throw new Error("Not authenticated");const[o]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!o?.id)throw new Error("No active tab");const e=await chrome.tabs.sendMessage(o.id,{type:"EXTRACT_ISSUE"});if(e.type==="EXTRACT_ERROR")throw new Error(e.error);if(e.type!=="EXTRACT_SUCCESS")throw new Error("Unexpected response type from content script");const t=e.payload.key;await u({isSyncing:!0,progress:30,status:`Fetched ${t}`,key:t});const a=await m();let n;const{selectedDoc:c}=await chrome.storage.local.get("selectedDoc");if(c)n=c,a[t]=n,await chrome.storage.local.set({issueDocLinks:a}),await chrome.storage.local.remove("selectedDoc");else if(a[t])n=a[t];else throw new Error("No target Document selected. Select one to link this issue.");await u({isSyncing:!0,progress:60,status:`Syncing ${t} to Google Docs...`,key:t}),await g.syncItem(n.id,e.payload,s),console.log(`Background: Sync successful for ${t} to ${n.name}`);const h=(await chrome.storage.local.get("issueSyncTimes")).issueSyncTimes||{},r={status:"success",time:Date.now(),message:`Synced to ${n.name}`,type:"single"};return h[t]=r,await chrome.storage.local.set({issueSyncTimes:h}),await u({isSyncing:!1,progress:100,status:"Complete!",key:t,result:r}),{success:!0,key:t,id:n.id}}catch(s){console.error("Background Sync Error:",s);let o=s.message;if(s.message?.includes("404")){o="The linked Google Doc no longer exists or is inaccessible. The local link has been cleared.";try{const e=await m(),[t]=await chrome.tabs.query({active:!0,currentWindow:!0});if(t?.id){const n=await chrome.tabs.sendMessage(t.id,{type:"EXTRACT_ISSUE"});if(n.type==="EXTRACT_SUCCESS"){const c=n.payload.key;e[c]&&(delete e[c],await chrome.storage.local.set({issueDocLinks:e}))}}const{selectedDoc:a}=await chrome.storage.local.get("selectedDoc");a&&await chrome.storage.local.remove("selectedDoc")}catch(e){console.error("Failed to cleanup dead links after 404:",e)}}throw await u({isSyncing:!1,progress:0,status:`Error: ${o}`,result:{status:"error",message:o,time:Date.now()}}),s}}async function x(s){try{const o=await d.getToken();if(!o)throw new Error("Google Docs not authenticated. Please disconnect and reconnect.");await u({isSyncing:!0,progress:5,status:"Initializing Bulk Sync...",key:s});const e=await m();let t=e[s];if(!t){const y=(await chrome.storage.local.get("selectedDoc")).selectedDoc;if(!y)throw new Error("No target Document selected. Link the Epic first.");t=y,e[s]=t,await chrome.storage.local.set({issueDocLinks:e})}const[a]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!a?.id)throw new Error("No active tab");const n=await chrome.tabs.sendMessage(a.id,{type:"FETCH_EPIC_BULK",payload:{epicKey:s}});if(n.type==="EXTRACT_ERROR")throw new Error(n.error);if(n.type!=="EPIC_BULK_SUCCESS")throw new Error("Expected EPIC_BULK_SUCCESS");const c=n.payload.items;console.log(`Background: Found ${c.length} issues in Epic ${s}`),await u({isSyncing:!0,progress:60,status:`Gathered ${c.length} items. Writing to Google Doc...`,key:s}),await g.syncItems(t.id,c,o);for(const w of c)e[w.key]||(e[w.key]=t);await chrome.storage.local.set({issueDocLinks:e});const h=(await chrome.storage.local.get("issueSyncTimes")).issueSyncTimes||{},r={status:"success",time:Date.now(),message:`Bulk synced ${c.length} issues to ${t.name}`,type:"bulk"};return h[s]=r,await chrome.storage.local.set({issueSyncTimes:h}),await u({isSyncing:!1,progress:100,status:"Bulk Sync Complete!",key:s,result:r}),{success:!0,count:c.length,key:s,id:t.id}}catch(o){console.error("Background Bulk Sync Error:",o);let e=o.message;if(o.message?.includes("404")){e="The linked Google Doc no longer exists. The link has been cleared.";try{const t=await m();t[s]&&(delete t[s],await chrome.storage.local.set({issueDocLinks:t}));const{selectedDoc:a}=await chrome.storage.local.get("selectedDoc");a&&await chrome.storage.local.remove("selectedDoc")}catch(t){console.error("Failed cleanup:",t)}}throw await u({isSyncing:!1,progress:0,status:`Error: ${e}`,key:s,result:{status:"error",message:e,time:Date.now()}}),o}}chrome.runtime.onMessage.addListener(s=>{if(s.type==="EPIC_BULK_PROGRESS"){const{current:o,total:e,key:t}=s.payload,a=5+Math.floor(o/e*55);u({isSyncing:!0,progress:a,status:`Processing ${t} (${o}/${e})...`,key:t})}});
