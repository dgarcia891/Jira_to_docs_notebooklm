import{f as w,n as E}from"./docUtils-CDeOq3Hw.js";const U=n=>{try{const o=n.replace("#","?");return new URL(o).searchParams.get("access_token")}catch{return null}};class I{scopes=["https://www.googleapis.com/auth/documents","https://www.googleapis.com/auth/drive","https://www.googleapis.com/auth/userinfo.email"];clientId="342225464153-i3qd0aru6fsna13sg2i0qmvtofnktgmb.apps.googleusercontent.com";async fetchToken(o){console.log(`GoogleAuth: fetchToken called (interactive: ${o})`);const e=await new Promise(t=>{if(typeof chrome>"u"||!chrome.identity||!chrome.identity.getAuthToken){t(null);return}chrome.identity.getAuthToken({interactive:o},a=>{chrome.runtime?.lastError||!a?(console.warn("GoogleAuth: Native getAuthToken failed/returned nothing:",chrome.runtime?.lastError?.message||"No token"),t(null)):t(a)})});return e?(await chrome.storage.local.set({auth_token:e,token_expiry:Date.now()+3e3*1e3}),e):o?(console.log("GoogleAuth: Attempting Fallback launchWebAuthFlow..."),new Promise(t=>{const a=chrome.identity.getRedirectURL(),r=`https://accounts.google.com/o/oauth2/auth?client_id=${this.clientId}&response_type=token&redirect_uri=${encodeURIComponent(a)}&scope=${encodeURIComponent(this.scopes.join(" "))}&prompt=consent`;chrome.identity.launchWebAuthFlow({url:r,interactive:!0},i=>{if(chrome.runtime?.lastError||!i)console.error("GoogleAuth: Fallback Auth Failed:",chrome.runtime?.lastError?.message),t(null);else{const c=U(i);c&&chrome.storage.local.set({auth_token:c,token_expiry:Date.now()+3e3*1e3}),t(c)}})})):null}async login(){const o=await this.fetchToken(!0);if(!o){const e=chrome.runtime?.lastError?.message;throw new Error(`Authentication failed: ${e||"No token returned"}`)}return o}async getToken(){const o=await chrome.storage.local.get(["auth_token","token_expiry"]),e=o.auth_token,t=o.token_expiry;if(e&&t&&t>Date.now()+300*1e3)return console.log("GoogleAuth: Using valid cached token from storage."),e;console.log("GoogleAuth: Storage token missing/expired. Attempting silent fetch...");const a=await this.fetchToken(!1);return!a&&e&&(console.warn("GoogleAuth: Silent refresh failed. Clearing stale token."),await this.clearCachedToken(e)),a}async clearCachedToken(o){console.log("GoogleAuth: Clearing cached token..."),await chrome.storage.local.remove(["auth_token","token_expiry","userInfo"]),o&&typeof chrome<"u"&&chrome.identity?.removeCachedAuthToken&&await new Promise(e=>{chrome.identity.removeCachedAuthToken({token:o},()=>e())})}async getUserInfo(o){const e=await fetch("https://www.googleapis.com/oauth2/v2/userinfo",{headers:{Authorization:`Bearer ${o}`}});if(!e.ok)throw new Error("Failed to fetch user info");return await e.json()}async logout(){await chrome.storage.local.remove(["auth_token","token_expiry","userInfo"]);try{const o=await this.getToken();o&&await new Promise(e=>{chrome.identity.removeCachedAuthToken({token:o},()=>e())})}catch{}console.log("GoogleAuth: Logged out and identity cache cleared.")}}class L{baseUrl="https://docs.googleapis.com/v1/documents";driveUrl="https://www.googleapis.com/drive/v3/files";async authFetch(o,e,t){let a=await fetch(o,e);return a.status===401&&(console.warn(`DocsSync: 401 Unauthorized for ${o}. Clearing token and retrying...`),await chrome.storage.local.remove(["auth_token","token_expiry"])),a}async createDoc(o,e,t){const a=await this.authFetch(this.baseUrl,{method:"POST",headers:{Authorization:`Bearer ${e}`,"Content-Type":"application/json"},body:JSON.stringify({title:o})},e);if(!a.ok){const c=await a.text();throw new Error(`Failed to create doc (${a.status}): ${c}`)}const i=(await a.json()).documentId;return t&&await this.moveToFolder(i,t,e),i}async moveToFolder(o,e,t){const i=((await(await this.authFetch(`${this.driveUrl}/${o}?fields=parents`,{headers:{Authorization:`Bearer ${t}`}},t)).json()).parents||[]).join(",");await this.authFetch(`${this.driveUrl}/${o}?addParents=${e}&removeParents=${i}`,{method:"PATCH",headers:{Authorization:`Bearer ${t}`}},t)}async listDocs(o){const t=await this.authFetch(`${this.driveUrl}?q=${encodeURIComponent("mimeType='application/vnd.google-apps.document' and trashed=false")}&fields=files(id,name)`,{headers:{Authorization:`Bearer ${o}`}},o);if(!t.ok){const r=await t.text();throw new Error(`Failed to list docs (${t.status}): ${r}`)}return(await t.json()).files||[]}async searchDocs(o,e){const t=`mimeType='application/vnd.google-apps.document' and name contains '${e.replace(/'/g,"\\'")}' and trashed=false`,a=await this.authFetch(`${this.driveUrl}?q=${encodeURIComponent(t)}&fields=files(id,name)&orderBy=modifiedTime desc`,{headers:{Authorization:`Bearer ${o}`}},o);if(!a.ok){const i=await a.text();throw new Error(`Failed to search docs (${a.status}): ${i}`)}return(await a.json()).files||[]}async listFolders(o,e){let t="mimeType='application/vnd.google-apps.folder' and trashed=false";e&&(t+=` and '${e}' in parents`);const a=await this.authFetch(`${this.driveUrl}?q=${encodeURIComponent(t)}&fields=files(id,name)&orderBy=name`,{headers:{Authorization:`Bearer ${o}`}},o);if(!a.ok){const i=await a.text();throw new Error(`Failed to list folders (${a.status}): ${i}`)}return(await a.json()).files||[]}async syncItem(o,e,t){return this.syncItems(o,[e],t)}async syncItems(o,e,t){const a=await this.getDoc(o,t),r=a.body.content[a.body.content.length-1].endIndex;console.log(`DocsSyncService: Wiping and syncing ${e.length} items to ${o}`);const i=[];r>2&&i.push({deleteContentRange:{range:{startIndex:1,endIndex:r-1}}});for(const s of e){const g=s.comments&&s.comments.length>0?s.comments.map(d=>`[${d.timestamp||"Unknown"}] ${d.author}: ${d.body.replace(/\*\*/g,"")}`).join(`
`):"_No recent comments_",y=[`Status: ${s.status}`,`Story Points: ${s.storyPoints||"N/A"}`,`Reporter: ${s.reporter||"N/A"}`,`Assignee: ${s.assignee||"Unassigned"}`,`Sprint History: ${s.sprints&&s.sprints.length>0?s.sprints.join(", "):"No Sprints"}`,`T-Shirt Size: ${s.tShirtSize||"N/A"}`,`Work Type: ${s.workType||"N/A"}`,`Business Team: ${s.businessTeam||"N/A"}`,`Business Objective: ${s.businessObjective||"N/A"}`,`Impact: ${s.impact||"N/A"}`,`Labels: ${s.labels&&s.labels.length>0?s.labels.join(", "):"None"}`,`Synced: ${w(new Date)}`,`Created: ${w(s.createdDate)} | Updated: ${w(s.updatedDate)}`].join(`
`);let k="";s.linkedIssues&&s.linkedIssues.length>0&&(k=`
Linked Tickets:
`+s.linkedIssues.map(d=>`* ${d.key}: ${d.title}
  - T-Shirt: ${d.tShirtSize||"N/A"}
  - Context: ${d.rationale||"N/A"}`).join(`
`)),`${s.key}${s.title}`,`${y}${s.url}${s.description}${k}${g}`}let c="";const m=[];for(const s of e){const g=s.comments&&s.comments.length>0?s.comments.map(l=>`[${l.timestamp||"Unknown"}] ${l.author}: ${l.body.replace(/\*\*/g,"")}`).join(`
`):"_No recent comments_",y=[`Status: ${s.status}`,`Story Points: ${s.storyPoints||"N/A"}`,`Reporter: ${s.reporter||"N/A"}`,`Assignee: ${s.assignee||"Unassigned"}`,`Sprint History: ${s.sprints&&s.sprints.length>0?s.sprints.join(", "):"No Sprints"}`,`T-Shirt Size: ${s.tShirtSize||"N/A"}`,`Work Type: ${s.workType||"N/A"}`,`Business Team: ${s.businessTeam||"N/A"}`,`Business Objective: ${s.businessObjective||"N/A"}`,`Impact: ${s.impact||"N/A"}`,`Labels: ${s.labels&&s.labels.length>0?s.labels.join(", "):"None"}`,`Synced: ${w(new Date)}`,`Created: ${w(s.createdDate)} | Updated: ${w(s.updatedDate)}`].join(`
`);let k="";s.linkedIssues&&s.linkedIssues.length>0&&(k=`
Linked Tickets:
`+s.linkedIssues.map(l=>{const N=l.comments&&l.comments.length>0?`
    Comments:
    `+l.comments.map(S=>`[${S.timestamp}] ${S.author}: ${S.body}`).join(`
    `):"";return`* ${l.key}: ${l.title}
  - Status: ${l.status||"N/A"} | Priority: ${l.priority||"N/A"}
  - Description: ${l.description||"No description"}
  - Link: ${l.url}${N}`}).join(`

`));const d=`${s.key}: ${s.title}
`,C=c.length+1;c+=d;const _=c.length+1;m.push({start:C,end:_,type:"HEADING_1"});const D=`${y}
Link: ${s.url}

Description
${s.description}
${k}

--------------------------------------------------
Latest Comments
${g}

---

`,A=c.length+1;c+=D;const b=c.length+1;m.push({start:A,end:b,type:"NORMAL_TEXT"})}i.push({insertText:{location:{index:1},text:c}});for(const s of m)i.push({updateParagraphStyle:{range:{startIndex:s.start,endIndex:s.end-1},paragraphStyle:{namedStyleType:s.type},fields:"namedStyleType"}});await this.batchUpdate(o,t,i)}async getDoc(o,e){const t=await this.authFetch(`${this.baseUrl}/${o}`,{headers:{Authorization:`Bearer ${e}`}},e);if(!t.ok){const a=await t.text();throw console.error(`DocsSync API Error [Get]: ${t.status}`,a),new Error(`Failed to fetch doc (${t.status}): ${a}`)}return await t.json()}async batchUpdate(o,e,t){const a=await this.authFetch(`${this.baseUrl}/${o}:batchUpdate`,{method:"POST",headers:{Authorization:`Bearer ${e}`,"Content-Type":"application/json"},body:JSON.stringify({requests:t})},e);if(!a.ok){const r=await a.text();throw console.error(`DocsSync API Error [BatchUpdate]: ${a.status}`,r),new Error(`Failed to update doc (${a.status}): ${r}`)}}}console.log("Jira to NotebookLM: Background service worker loaded");const $=async(n,o)=>{if(n.includes(".chromiumapp.org/")&&n.includes("access_token=")){console.log("Background: Intercepted Token URL:",n);try{const e=n.replace("#","?"),t=new URL(e),a=t.searchParams.get("access_token"),r=t.searchParams.get("expires_in");if(a){const i=Date.now()+parseInt(r||"3599")*1e3;await chrome.storage.local.set({auth_token:a,token_expiry:i}),console.log("Background: Auth successful. Notifying popup and closing tab."),chrome.runtime.sendMessage({type:"AUTH_SUCCESS"}).catch(()=>{}),setTimeout(()=>{chrome.tabs.remove(o).catch(()=>{})},100)}}catch(e){console.error("Background: Token extraction error:",e)}}};chrome.tabs.onUpdated.addListener((n,o,e)=>{o.url&&$(o.url,n)});chrome.tabs.onCreated.addListener(n=>{n.id&&n.url&&$(n.url,n.id)});chrome.webNavigation.onBeforeNavigate.addListener(n=>{n.frameId===0&&$(n.url,n.tabId)});chrome.webNavigation.onCommitted.addListener(n=>{n.frameId===0&&$(n.url,n.tabId)});const u=new I,p=new L;chrome.runtime.onMessage.addListener((n,o,e)=>(T(n).then(e).catch(t=>{if(!t.message?.includes("Extension updated")){const r={message:t.message||"Unknown error",name:t.name,stack:t.stack,original:t};console.error("Background Error Detailed:",JSON.stringify(r,null,2))}e({error:t.message||JSON.stringify(t)})}),!0));async function T(n,o=0){try{switch(n.type){case"LOGIN":return console.log("Background: Triggering LOGIN flow..."),await u.login();case"CHECK_AUTH":return await u.getToken();case"LIST_DOCS":{const e=await u.getToken();if(!e)throw new Error("Not authenticated");return await p.listDocs(e)}case"LIST_DRIVE_FOLDERS":{const e=await u.getToken();if(!e)throw new Error("Not authenticated");return await p.listFolders(e,n.payload?.parentId)}case"SEARCH_DOCS":{const e=await u.getToken();if(!e)throw new Error("Not authenticated");return await p.searchDocs(e,n.payload.query)}case"CREATE_DOC":{const e=await u.getToken();if(!e)throw new Error("Not authenticated");return await p.createDoc(n.payload.title,e,n.payload.folderId)}case"GET_CURRENT_ISSUE_KEY":{const[e]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!e?.id)throw new Error("No active tab found.");try{const t=await chrome.tabs.sendMessage(e.id,{type:"GET_ISSUE_KEY"});if(t.error)throw new Error(t.error);return t}catch(t){throw console.warn("Background: GET_CURRENT_ISSUE_KEY failed",t),t.message?.includes("Could not establish connection")||t.message?.includes("context invalidated")?new Error("Extension updated. Please refresh your Jira page to continue."):new Error("Please open the extension on a Jira issue page.")}}case"GET_SELECTED_DOC":{const e=await chrome.storage.local.get("selectedDoc");return E(e.selectedDoc)}case"SET_SELECTED_DOC":return await chrome.storage.local.set({selectedDoc:n.payload}),!0;case"SYNC_CURRENT_PAGE":return await v();case"SYNC_EPIC":return await B(n.payload.epicKey);case"GET_ISSUE_DOC_LINK":{const{issueKey:e}=n.payload;return(await f())[e]||null}case"CLEAR_ISSUE_DOC_LINK":{const{issueKey:e}=n.payload,t=await f();return delete t[e],await chrome.storage.local.set({issueDocLinks:t}),!0}case"GET_LAST_SYNC":{const{issueKey:e}=n.payload;return((await chrome.storage.local.get("issueSyncTimes")).issueSyncTimes||{})[e]||null}case"LOGOUT":return await u.logout()}}catch(e){if(e.message?.includes("401")&&o===0)return console.warn("Background: 401 detected in handleMessage. Clearing cache and retrying..."),await u.clearCachedToken(),await T(n,1);throw e}}async function f(){const o=(await chrome.storage.local.get("issueDocLinks")).issueDocLinks||{},e={};for(const t in o){const a=E(o[t]);a&&(e[t]=a)}return e}async function h(n){await chrome.storage.local.set({activeSyncState:n}),chrome.runtime.sendMessage({type:"SYNC_STATE_UPDATE",payload:n}).catch(()=>{})}async function v(){try{const n=await u.getToken();if(!n)throw new Error("Not authenticated");const[o]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!o?.id)throw new Error("No active tab");await h({isSyncing:!0,progress:10,status:"Initializing...",key:"pending"});const e=await chrome.tabs.sendMessage(o.id,{type:"EXTRACT_ISSUE"});if(e.type==="EXTRACT_ERROR")throw new Error(e.error);if(e.type!=="EXTRACT_SUCCESS")throw new Error("Unexpected response type from content script");const t=e.payload.key;await h({isSyncing:!0,progress:30,status:`Fetched ${t}`,key:t});const a=await f();let r;if(a[t])r=a[t];else{const{selectedDoc:s}=await chrome.storage.local.get("selectedDoc");if(!s)throw new Error("No target Document selected. Select one to link this issue.");r=s,a[t]=r,await chrome.storage.local.set({issueDocLinks:a})}await h({isSyncing:!0,progress:60,status:`Syncing ${t} to Google Docs...`,key:t}),await p.syncItem(r.id,e.payload,n),console.log(`Background: Sync successful for ${t} to ${r.name}`);const c=(await chrome.storage.local.get("issueSyncTimes")).issueSyncTimes||{},m={status:"success",time:Date.now(),message:`Synced to ${r.name}`};return c[t]=m,await chrome.storage.local.set({issueSyncTimes:c,lastSyncType:"single"}),await h({isSyncing:!1,progress:100,status:"Complete!",key:t,result:m}),{success:!0,key:t,id:r.id}}catch(n){throw console.error("Background Sync Error:",n),await h({isSyncing:!1,progress:0,status:`Error: ${n.message}`,result:{status:"error",message:n.message,time:Date.now()}}),n}}async function B(n){try{const o=await u.getToken();if(!o)throw new Error("Google Docs not authenticated. Please disconnect and reconnect.");await h({isSyncing:!0,progress:5,status:"Initializing Bulk Sync...",key:n});const e=await f();let t=e[n];if(!t){const y=(await chrome.storage.local.get("selectedDoc")).selectedDoc;if(!y)throw new Error("No target Document selected. Link the Epic first.");t=y,e[n]=t,await chrome.storage.local.set({issueDocLinks:e})}const[a]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!a?.id)throw new Error("No active tab");const r=await chrome.tabs.sendMessage(a.id,{type:"FETCH_EPIC_BULK",payload:{epicKey:n}});if(r.type==="EXTRACT_ERROR")throw new Error(r.error);if(r.type!=="EPIC_BULK_SUCCESS")throw new Error("Expected EPIC_BULK_SUCCESS");const i=r.payload.items;console.log(`Background: Found ${i.length} issues in Epic ${n}`),await h({isSyncing:!0,progress:60,status:`Gathered ${i.length} items. Writing to Google Doc...`,key:n}),await p.syncItems(t.id,i,o);for(const g of i)e[g.key]||(e[g.key]=t);await chrome.storage.local.set({issueDocLinks:e});const m=(await chrome.storage.local.get("issueSyncTimes")).issueSyncTimes||{},s={status:"success",time:Date.now(),message:`Bulk synced ${i.length} issues to ${t.name}`};return m[n]=s,await chrome.storage.local.set({issueSyncTimes:m,lastSyncType:"bulk"}),await h({isSyncing:!1,progress:100,status:"Bulk Sync Complete!",key:n,result:s}),{success:!0,count:i.length,key:n,id:t.id}}catch(o){throw console.error("Background Epic Sync Error:",o),await h({isSyncing:!1,progress:0,status:`Bulk Sync Error: ${o.message}`,result:{status:"error",message:o.message,time:Date.now()}}),o}}chrome.runtime.onMessage.addListener(n=>{if(n.type==="EPIC_BULK_PROGRESS"){const{current:o,total:e,key:t}=n.payload,a=5+Math.floor(o/e*55);h({isSyncing:!0,progress:a,status:`Processing ${t} (${o}/${e})...`,key:t})}});
