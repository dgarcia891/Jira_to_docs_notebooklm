const A=s=>{try{const e=s.replace("#","?");return new URL(e).searchParams.get("access_token")}catch{return null}};class _{scopes=["https://www.googleapis.com/auth/documents","https://www.googleapis.com/auth/drive","https://www.googleapis.com/auth/userinfo.email"];clientId="342225464153-i3qd0aru6fsna13sg2i0qmvtofnktgmb.apps.googleusercontent.com";async fetchToken(e){console.log(`GoogleAuth: fetchToken called (interactive: ${e})`);const t=await new Promise(o=>{if(typeof chrome>"u"||!chrome.identity||!chrome.identity.getAuthToken){o(null);return}chrome.identity.getAuthToken({interactive:e},a=>{chrome.runtime?.lastError||!a?(console.warn("GoogleAuth: Native getAuthToken failed/returned nothing:",chrome.runtime?.lastError?.message||"No token"),o(null)):o(a)})});return t?(await chrome.storage.local.set({auth_token:t,token_expiry:Date.now()+3500*1e3}),t):e?(console.log("GoogleAuth: Attempting Fallback launchWebAuthFlow..."),new Promise(o=>{const a=chrome.identity.getRedirectURL(),r=`https://accounts.google.com/o/oauth2/auth?client_id=${this.clientId}&response_type=token&redirect_uri=${encodeURIComponent(a)}&scope=${encodeURIComponent(this.scopes.join(" "))}&prompt=consent`;chrome.identity.launchWebAuthFlow({url:r,interactive:!0},i=>{if(chrome.runtime?.lastError||!i)console.error("GoogleAuth: Fallback Auth Failed:",chrome.runtime?.lastError?.message),o(null);else{const c=A(i);c&&chrome.storage.local.set({auth_token:c,token_expiry:Date.now()+3500*1e3}),o(c)}})})):null}async login(){const e=await this.fetchToken(!0);if(!e){const t=chrome.runtime?.lastError?.message;throw new Error(`Authentication failed: ${t||"No token returned"}`)}return e}async getToken(){const e=await chrome.storage.local.get(["auth_token","token_expiry"]),t=e.auth_token,o=e.token_expiry;return t&&o&&o>Date.now()?(console.log("GoogleAuth: Using valid cached token from storage."),t):(console.log("GoogleAuth: Storage token missing/expired. Attempting silent fetch..."),await this.fetchToken(!1))}async getUserInfo(e){const t=await fetch("https://www.googleapis.com/oauth2/v2/userinfo",{headers:{Authorization:`Bearer ${e}`}});if(!t.ok)throw new Error("Failed to fetch user info");return await t.json()}async logout(){await chrome.storage.local.remove(["auth_token","token_expiry","userInfo"]);try{const e=await this.getToken();e&&await new Promise(t=>{chrome.identity.removeCachedAuthToken({token:e},()=>t())})}catch{}console.log("GoogleAuth: Logged out and identity cache cleared.")}}class C{baseUrl="https://docs.googleapis.com/v1/documents";driveUrl="https://www.googleapis.com/drive/v3/files";async createDoc(e,t,o){const a=await fetch(this.baseUrl,{method:"POST",headers:{Authorization:`Bearer ${t}`,"Content-Type":"application/json"},body:JSON.stringify({title:e})});if(!a.ok){const c=await a.text();throw new Error(`Failed to create doc (${a.status}): ${c}`)}const i=(await a.json()).documentId;return o&&await this.moveToFolder(i,o,t),i}async moveToFolder(e,t,o){const i=((await(await fetch(`${this.driveUrl}/${e}?fields=parents`,{headers:{Authorization:`Bearer ${o}`}})).json()).parents||[]).join(",");await fetch(`${this.driveUrl}/${e}?addParents=${t}&removeParents=${i}`,{method:"PATCH",headers:{Authorization:`Bearer ${o}`}})}async listDocs(e){const o=await fetch(`${this.driveUrl}?q=${encodeURIComponent("mimeType='application/vnd.google-apps.document' and trashed=false")}&fields=files(id,name)`,{headers:{Authorization:`Bearer ${e}`}});if(!o.ok){const r=await o.text();throw new Error(`Failed to list docs (${o.status}): ${r}`)}return(await o.json()).files||[]}async searchDocs(e,t){const o=`mimeType='application/vnd.google-apps.document' and name contains '${t.replace(/'/g,"\\'")}' and trashed=false`,a=await fetch(`${this.driveUrl}?q=${encodeURIComponent(o)}&fields=files(id,name)&orderBy=modifiedTime desc`,{headers:{Authorization:`Bearer ${e}`}});if(!a.ok){const i=await a.text();throw new Error(`Failed to search docs (${a.status}): ${i}`)}return(await a.json()).files||[]}async listFolders(e,t){let o="mimeType='application/vnd.google-apps.folder' and trashed=false";t&&(o+=` and '${t}' in parents`);const a=await fetch(`${this.driveUrl}?q=${encodeURIComponent(o)}&fields=files(id,name)&orderBy=name`,{headers:{Authorization:`Bearer ${e}`}});if(!a.ok){const i=await a.text();throw new Error(`Failed to list folders (${a.status}): ${i}`)}return(await a.json()).files||[]}async syncItem(e,t,o){return this.syncItems(e,[t],o)}async syncItems(e,t,o){const a=await this.getDoc(e,o),r=a.body.content[a.body.content.length-1].endIndex;console.log(`DocsSyncService: Wiping and syncing ${t.length} items to ${e}`);const i=[];r>2&&i.push({deleteContentRange:{range:{startIndex:1,endIndex:r-1}}});for(const n of t){const m=n.comments&&n.comments.length>0?n.comments.map(l=>`[${l.timestamp||"Unknown"}] ${l.author}: ${l.body.replace(/\*\*/g,"")}`).join(`
`):"_No recent comments_",f=[`Status: ${n.status}`,`Reporter: ${n.reporter||"N/A"}`,`Assignee: ${n.assignee||"Unassigned"}`,`Sprint History: ${n.sprints&&n.sprints.length>0?n.sprints.join(", "):"No Sprints"}`,`T-Shirt Size: ${n.tShirtSize||"N/A"}`,`Work Type: ${n.workType||"N/A"}`,`Business Team: ${n.businessTeam||"N/A"}`,`Business Objective: ${n.businessObjective||"N/A"}`,`Impact: ${n.impact||"N/A"}`,`Labels: ${n.labels&&n.labels.length>0?n.labels.join(", "):"None"}`,`Synced: ${new Date().toLocaleString()}`,`Created: ${n.createdDate?new Date(n.createdDate).toLocaleString():"N/A"} | Updated: ${n.updatedDate?new Date(n.updatedDate).toLocaleString():"N/A"}`].join(`
`);let w="";n.linkedIssues&&n.linkedIssues.length>0&&(w=`
Linked Tickets:
`+n.linkedIssues.map(l=>`* ${l.key}: ${l.title}
  - T-Shirt: ${l.tShirtSize||"N/A"}
  - Context: ${l.rationale||"N/A"}`).join(`
`)),`${n.key}${n.title}`,`${f}${n.url}${n.description}${w}${m}`}let c="";const d=[];for(const n of t){const m=n.comments&&n.comments.length>0?n.comments.map(h=>`[${h.timestamp||"Unknown"}] ${h.author}: ${h.body.replace(/\*\*/g,"")}`).join(`
`):"_No recent comments_",f=[`Status: ${n.status}`,`Reporter: ${n.reporter||"N/A"}`,`Assignee: ${n.assignee||"Unassigned"}`,`Sprint History: ${n.sprints&&n.sprints.length>0?n.sprints.join(", "):"No Sprints"}`,`T-Shirt Size: ${n.tShirtSize||"N/A"}`,`Work Type: ${n.workType||"N/A"}`,`Business Team: ${n.businessTeam||"N/A"}`,`Business Objective: ${n.businessObjective||"N/A"}`,`Impact: ${n.impact||"N/A"}`,`Labels: ${n.labels&&n.labels.length>0?n.labels.join(", "):"None"}`,`Synced: ${new Date().toLocaleString()}`,`Created: ${n.createdDate?new Date(n.createdDate).toLocaleString():"N/A"} | Updated: ${n.updatedDate?new Date(n.updatedDate).toLocaleString():"N/A"}`].join(`
`);let w="";n.linkedIssues&&n.linkedIssues.length>0&&(w=`
Linked Tickets:
`+n.linkedIssues.map(h=>`* ${h.key}: ${h.title}
  - T-Shirt: ${h.tShirtSize||"N/A"}
  - Context: ${h.rationale||"N/A"}`).join(`
`));const l=`${n.key}: ${n.title}
`,$=c.length+1;c+=l;const S=c.length+1;d.push({start:$,end:S,type:"HEADING_1"});const E=`${f}
Link: ${n.url}

Description
${n.description}
${w}

--------------------------------------------------
Latest Comments
${m}

---

`,T=c.length+1;c+=E;const D=c.length+1;d.push({start:T,end:D,type:"NORMAL_TEXT"})}i.push({insertText:{location:{index:1},text:c}});for(const n of d)i.push({updateParagraphStyle:{range:{startIndex:n.start,endIndex:n.end-1},paragraphStyle:{namedStyleType:n.type},fields:"namedStyleType"}});await this.batchUpdate(e,o,i)}async getDoc(e,t){const o=await fetch(`${this.baseUrl}/${e}`,{headers:{Authorization:`Bearer ${t}`}});if(!o.ok){const a=await o.text();throw console.error(`DocsSync API Error [Get]: ${o.status}`,a),new Error(`Failed to fetch doc (${o.status}): ${a}`)}return await o.json()}async batchUpdate(e,t,o){const a=await fetch(`${this.baseUrl}/${e}:batchUpdate`,{method:"POST",headers:{Authorization:`Bearer ${t}`,"Content-Type":"application/json"},body:JSON.stringify({requests:o})});if(!a.ok){const r=await a.text();throw console.error(`DocsSync API Error [BatchUpdate]: ${a.status}`,r),new Error(`Failed to update doc (${a.status}): ${r}`)}}}function k(s){return s?{id:s.id||s.docId,name:s.name}:null}console.log("Jira to NotebookLM: Background service worker loaded");const y=async(s,e)=>{if(s.includes(".chromiumapp.org/")&&s.includes("access_token=")){console.log("Background: Intercepted Token URL:",s);try{const t=s.replace("#","?"),o=new URL(t),a=o.searchParams.get("access_token"),r=o.searchParams.get("expires_in");if(a){const i=Date.now()+parseInt(r||"3599")*1e3;await chrome.storage.local.set({auth_token:a,token_expiry:i}),console.log("Background: Auth successful. Notifying popup and closing tab."),chrome.runtime.sendMessage({type:"AUTH_SUCCESS"}).catch(()=>{}),setTimeout(()=>{chrome.tabs.remove(e).catch(()=>{})},100)}}catch(t){console.error("Background: Token extraction error:",t)}}};chrome.tabs.onUpdated.addListener((s,e,t)=>{e.url&&y(e.url,s)});chrome.tabs.onCreated.addListener(s=>{s.id&&s.url&&y(s.url,s.id)});chrome.webNavigation.onBeforeNavigate.addListener(s=>{s.frameId===0&&y(s.url,s.tabId)});chrome.webNavigation.onCommitted.addListener(s=>{s.frameId===0&&y(s.url,s.tabId)});const u=new _,g=new C;chrome.runtime.onMessage.addListener((s,e,t)=>(N(s).then(t).catch(o=>{const a={message:o.message||"Unknown error",name:o.name,stack:o.stack,original:o};console.error("Background Error Detailed:",JSON.stringify(a,null,2)),t({error:o.message||JSON.stringify(o)})}),!0));async function N(s){switch(s.type){case"LOGIN":return console.log("Background: Triggering LOGIN flow..."),await u.login();case"CHECK_AUTH":return await u.getToken();case"LIST_DOCS":{const e=await u.getToken();if(!e)throw new Error("Not authenticated");return await g.listDocs(e)}case"LIST_DRIVE_FOLDERS":{const e=await u.getToken();if(!e)throw new Error("Not authenticated");return await g.listFolders(e,s.payload?.parentId)}case"SEARCH_DOCS":{const e=await u.getToken();if(!e)throw new Error("Not authenticated");return await g.searchDocs(e,s.payload.query)}case"CREATE_DOC":{const e=await u.getToken();if(!e)throw new Error("Not authenticated");return await g.createDoc(s.payload.title,e,s.payload.folderId)}case"GET_CURRENT_ISSUE_KEY":{const[e]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!e?.id)throw new Error("No active tab found.");try{const t=await chrome.tabs.sendMessage(e.id,{type:"GET_ISSUE_KEY"});if(t.error)throw new Error(t.error);return t}catch(t){throw console.warn("Background: GET_CURRENT_ISSUE_KEY failed",t),t.message?.includes("Could not establish connection")||t.message?.includes("context invalidated")?new Error("Extension updated. Please refresh your Jira page to continue."):new Error("Please open the extension on a Jira issue page.")}}case"GET_SELECTED_DOC":{const e=await chrome.storage.local.get("selectedDoc");return k(e.selectedDoc)}case"SET_SELECTED_DOC":return await chrome.storage.local.set({selectedDoc:s.payload}),!0;case"SYNC_CURRENT_PAGE":return await b();case"SYNC_EPIC":return await U(s.payload.epicKey);case"GET_ISSUE_DOC_LINK":{const{issueKey:e}=s.payload;return(await p())[e]||null}case"CLEAR_ISSUE_DOC_LINK":{const{issueKey:e}=s.payload,t=await p();return delete t[e],await chrome.storage.local.set({issueDocLinks:t}),!0}case"GET_LAST_SYNC":{const{issueKey:e}=s.payload;return((await chrome.storage.local.get("issueSyncTimes")).issueSyncTimes||{})[e]||null}case"LOGOUT":return await u.logout()}}async function p(){const e=(await chrome.storage.local.get("issueDocLinks")).issueDocLinks||{},t={};for(const o in e){const a=k(e[o]);a&&(t[o]=a)}return t}async function b(){try{const s=await u.getToken();if(!s)throw new Error("Not authenticated");const[e]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!e?.id)throw new Error("No active tab");const t=await chrome.tabs.sendMessage(e.id,{type:"EXTRACT_ISSUE"});if(t.type==="EXTRACT_ERROR")throw new Error(t.error);if(t.type!=="EXTRACT_SUCCESS")throw new Error("Unexpected response type from content script");const o=t.payload.key,a=await p();let r;if(a[o])r=a[o];else{const{selectedDoc:d}=await chrome.storage.local.get("selectedDoc");if(!d)throw new Error("No target Document selected. Select one to link this issue.");r=d,a[o]=r,await chrome.storage.local.set({issueDocLinks:a})}await g.syncItem(r.id,t.payload,s),console.log(`Background: Sync successful for ${o} to ${r.name}`);const c=(await chrome.storage.local.get("issueSyncTimes")).issueSyncTimes||{};return c[o]={status:"success",time:Date.now(),message:`Synced to ${r.name}`},await chrome.storage.local.set({issueSyncTimes:c,lastSyncType:"single"}),{success:!0,key:o,id:r.id}}catch(s){throw console.error("Background Sync Error:",s),s}}async function U(s){try{const e=await u.getToken();if(!e)throw new Error("Google Docs not authenticated. Please disconnect and reconnect.");const t=await p();let o=t[s];if(!o){const m=(await chrome.storage.local.get("selectedDoc")).selectedDoc;if(!m)throw new Error("No target Document selected. Link the Epic first.");o=m,t[s]=o,await chrome.storage.local.set({issueDocLinks:t})}const[a]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!a?.id)throw new Error("No active tab");const r=await chrome.tabs.sendMessage(a.id,{type:"FETCH_EPIC_BULK",payload:{epicKey:s}});if(r.type==="EXTRACT_ERROR")throw new Error(r.error);if(r.type!=="EPIC_BULK_SUCCESS")throw new Error("Expected EPIC_BULK_SUCCESS");const i=r.payload.items;console.log(`Background: Found ${i.length} issues in Epic ${s}`),await g.syncItems(o.id,i,e);for(const n of i)t[n.key]||(t[n.key]=o);await chrome.storage.local.set({issueDocLinks:t});const d=(await chrome.storage.local.get("issueSyncTimes")).issueSyncTimes||{};return d[s]={status:"success",time:Date.now(),message:`Bulk synced ${i.length} issues to ${o.name}`},await chrome.storage.local.set({issueSyncTimes:d,lastSyncType:"bulk"}),{success:!0,count:i.length,key:s,id:o.id}}catch(e){throw console.error("Background Epic Sync Error:",e),e}}
